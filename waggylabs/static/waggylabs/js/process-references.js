/**

 */

function processLabels(el) {
    const classNames = ['blockquote', 'embed', 'figure', 'listing', 'table'];

}

/**
 * Processes figure, table, listing, blockquote references before 
 * MathJax does the same for equations.
 * @param {DOM element} el - element which innerHTML needs processing
 */
function processRefs(el) {
    const classNames = ['blockquote', 'embed', 'figure', 'listing', 'table'];
    const navbar = document.getElementById('navbar-header');
    var navbarHeight = '10px';
    if (navbar.classList.contains('sticky-top') || navbar.classList.contains('fixed-top')) {
        navbarHeight = String(navbar.offsetHeight + 10) + 'px';
    }
    for (let j in classNames) {
        var labelElements = el.getElementsByClassName('waggylabs-label-' + classNames[j]);
        for(var i = 0; i < labelElements.length; i++) {
            // Add numbers to the elements if caption is present
            var entityLabel = labelElements[i].getElementsByClassName('waggylabs-entity-label');
            if (entityLabel[0]) {
                entityLabel[0].innerHTML = entityLabel[0].innerHTML + ' ' + String(i + 1) + '.';
                var sb = document.getElementById('sb-' + entityLabel[0].id);
                var modal = document.getElementById('modal-' + entityLabel[0].id);
                if (sb) { sb.innerHTML = entityLabel[0].innerHTML; }
                if (modal) { modal.innerHTML = entityLabel[0].innerHTML; }
            }
            // Replace \ref{...} blocks with numbers of corresponding blocks
            var label = labelElements[i].id;
            var regex = new RegExp('\\\\ref\{' + label + '\}', 'g');
            el.innerHTML = el.innerHTML.replace(regex, 
               `<span class="reference"><a href="#${label}">${i + 1}</a></span>`);
            // TODO: add correct class to the referenced elements for scrolling if navbar is fixed
            labelElements[i].style.setProperty('scroll-margin-top', navbarHeight);
        }
    }
}

/**
 * Updates scroll-margin-top style setting for MathJax labels 
 * @param {DOM element} el - element within which lebels will be processed
 */
function updateMathJaxScroll(el) {
    const navbar = document.getElementById('navbar-header');
    var navbarHeight = '10px';
    if (navbar.classList.contains('sticky-top') || navbar.classList.contains('fixed-top')) {
        navbarHeight = String(navbar.offsetHeight + 10) + 'px';

        el.querySelectorAll('mjx-labels').forEach((label) => {
            label.querySelectorAll('mjx-mtd').forEach((number) => {
                number.style.setProperty('scroll-margin-top', navbarHeight);
            });
        });
    }
}

/**
 * Processes the equation labels for sidebar and sidebar modals after MathJas
 * has done typesetting.
 * @param {DOM element} el - element within which equations will be processed.
 */
function processSidebarEquations(el) {
    var eqElements = el.getElementsByClassName('waggylabs-label-equation');
    for (var i = 0; i < eqElements.length; i++) {
        // First get label for each equation and check it exists
        var entityLabel = eqElements[i].getElementsByClassName('waggylabs-entity-label');
        if (entityLabel[0]) {
            // If label exists - get the equation number generated by MathJax
            var numElement = eqElements[i].querySelector('mjx-labels').querySelector('mjx-mtext');
            if (numElement) {
                var eqNumber = '';
                for (var j = 1; j < numElement.children.length - 1; j++) {
                    eqNumber = eqNumber + numElement.children[j].classList[0].slice(-1);
                }
                if (eqNumber) {
                    entityLabel[0].innerHTML = entityLabel[0].innerHTML + ' ' + eqNumber + '.';
                }
            }
            var sb = document.getElementById('sb-' + entityLabel[0].id);
            var modal = document.getElementById('modal-' + entityLabel[0].id);
            if (sb) { sb.innerHTML = entityLabel[0].innerHTML; }
            if (modal) { modal.innerHTML = entityLabel[0].innerHTML; }
        }
    }
}

/**
 * Processes literature citations and gererates references
 * @param {DOM element} el - element which innterHTML needs processing 
 */
function processCites(el) {
    const navbar = document.getElementById('navbar-header');
    var navbarHeight = '10px';
    if (navbar.classList.contains('sticky-top') || navbar.classList.contains('fixed-top')) {
        navbarHeight = String(navbar.offsetHeight + 10) + 'px';
    }
    var labelElements = el.getElementsByClassName('waggylabs-label-cite');
    var labelIds = []; // needed to collect the ids of the elements containing citations
    for (var i = 0; i < labelElements.length; i++) {
        labelElements[i].innerHTML = i + 1;
        labelIds.push(labelElements[i].id);
        labelElements[i].style.setProperty('scroll-margin-top', navbarHeight);
    }
    // var citeIds = []; // keeps the ids of for the current \cite{...}
    var re = /\\cite{(.*?)}/g;
    var matches = [];
    var citeHTMLs = [];
    var match;
    while (match = re.exec(el.innerHTML)) {
        var cites = match[1].split(","); // there can be more than one citation
        var citeIds = []; // keeps the ids of for the current \cite{...}
        for (let i in cites) {
            citeIds.push(labelIds.indexOf(cites[i]));
        }
        citeIds.sort();
        var citeHTML = "";
        for (let i in citeIds) {
            if (citeIds[i] === -1) {
                citeHTML = citeHTML + `<span class="reference"><a href="#">???</a></span>,`;
            }
            else {
                citeHTML = citeHTML + `<span class="reference"><a href="#${labelIds[citeIds[i]]}">${citeIds[i] + 1}</a></span>,`;
            }
        }
        matches.push(match[0]);
        citeHTMLs.push('[' + citeHTML.slice(0, -1) + ']');
    }
    for (let i in matches) {
        el.innerHTML = el.innerHTML.replace(matches[i], citeHTMLs[i]);
    }
}
